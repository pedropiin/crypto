# Respostas

## Prova teorema pós 3.25 (pág. 78)
Objetivamos provar que podemos construir uma função pseudoaleatória (PRF) *F* a partir de um gerador pseudoaleatório (PRG) *G*. Portanto, suponhamos que *G* seja um gerador pseudoaleatório válido. Por definição, |P[D(G(k)) = 1] - P[D(r) = 1] $\le$ negl, ou seja, para qualquer diferenciador *D* PPT, a probabilidade de *D* conseguir diferenciar G(k) de uma string uniforme aleatória é insignificante. Porém, vamos provar que se existe um diferenciador *D'* que consegue diferenciar *Fk* de uma função verdadeiramente aleatória, podemos utilizá-lo para construir um diferenciador *D* que distingue entre *G(k)* e uma string aleatória.
O diferenciador *D* funciona da seguinte forma: dado uma string *s*, com |*s*| = *n* * 2<sup>t(n)</sup>, dada pela entrada, *D* busca descobrir se *s* foi amostrada de uma distribuição uniforme ou se foi gerada por G(k). Como dado pelo parágrafo, *Fk* é interpretada como uma lookup-table de 2<sup>t(n)</sup> colunas com strings de tamanho *n* em cada uma. Portanto, é possível construir uma nova função *F'* com base em *s*, em que *F'(i)* equivale ao *i*-ésimo bloco de tamanho *n* de *s*. Assim, *D* chama *D'* passando *F'(i)* como parâmetro e devolve o mesmo resultado que *D'*. Se *D'* devolver 0, significa que a função *F'(i)* não é aleatória, e 1 caso contrário. Assim, como *F'(i)* foi construída com base na string *s*, sabemos que ambas estruturas possuem as mesmas propriedades, e que, portanto, *D* responderia corretamente toda vez que *D'* respondesse corretamente. Porém, como G é um gerador pseudoaleatório, não é possível existir um *D'* que diferencie *F'* de uma função verdadeiramente aleatória com probabilidade maior que insignificante, já que implicaria em uma contradição com a definição de G. Portanto, conclui-se que *F* gerada por G é pseudoaleatória.

## 3.1) Prove Proposition 3.6
1. Seja q(n) um polinômio qualquer, tal que *negl<sub>1</sub>(n)* < 1/(2 * q(n)), para qualquer *n* > *N<sub>1</sub>* e  *negl<sub>2</sub>(n)* < 1/(2 * q(n)), para qualquer *n* > *N<sub>2</sub>*. Ambas funções são insignificantes, pois respeitam as condições de definição de tal classe de funções, já que q(n) é um polinômio qualquer. Definimos juntamente *N<sub>3</sub>* como max(*N<sub>1</sub>*, *N<sub>2</sub>*). Desse modo: *negl<sub>1</sub>(n)* < 1/(2 * q(n)) e *negl<sub>2</sub>(n)* < 1/(2 * q(n)), para qualquer *n* > *N<sub>3</sub>*, implicando que *negl<sub>1</sub>(n)* + *negl<sub>2</sub>(n)* < 1/(2 * q(n)) + 1/(2 * q(n)) = 1/q(n). Como *negl<sub>3</sub>(n)* = *negl<sub>1</sub>(n)* + *negl<sub>2</sub>(n)* por definição, segue que *negl<sub>3</sub>(n) < 1/q(n)* para qualquer *n* < *N<sub>3</sub>* e que, portanto, é também uma função insignificante.
2. Seja q(n) um polinômio qualquer, tal que *negl<sub>1</sub>(n)* < 1/(p(n) * q(n)) para qualquer *n* > *N<sub>1</sub>*. Válido, pois, por propriedade de polinômios, se p(n) e q(n) são polinômios, p(n) * q(n) também é. Assim, p(n) * *negl<sub>1</sub>(n)* < p(n) * 1/(p(n) * q(n)) = 1/q(n), para qualquer *n* > *N*. Consequentemente, *negl<sub>4</sub>(n)* = p(n) * *negl<sub>1</sub>(n)* < 1/q(n) para qualquer *n* > *N* e, portanto, também é uma função insignificante.

## 3.2) Prove that Definition 3.8 cannot be satisfied if $\Pi$ can encrypt arbitrary-length messages and the adversary is not restricted to outputting equal-length messages in experiment PrivK<sub>A, Π</sub><sup>eav</sup>.
Seja q(n) o tamanho máximo possível de ciphertext gerado quando **Enc** é utilizado para encriptar um único bit. Desse modo, basta criarmos um adversário *A* que seleciona duas mensagens *m0* e *m1*, tal que |*m0*| = 1 e |*m1*| = q(n) + x, com x > 0, ou seja, *m0* consiste em um único bit e *m1* consiste em uma mensagem maior que q(n). Dado um ciphertext de desafio *c*, sabe-se então que *b* = 0 $\iff$ |*c*| $\le$ q(n) e *b* = 1 $\iff$ |*c*| > q(n) sempre que as mensagens dadas para o experimento seguem o formato estipulado. Consequentemente, basta o adversário *A* devolver *b'* conforme as condições descritas que será bem sucedido com probabilidade > 1/2 + *negl*(n)

## 3.3) Say $\Pi$ = (Gen, Enc, Dec) is such that for *k* $\in$ {0, 1}<sup>n</sup>, algorithm Enc<sub>k</sub> is only defined for messages of length at most *l*(n) (for some polynomial *l*). Construct a scheme satisfying Definition 3.8 even when the adversary is *not* restricted to outputting equal-length messages in PrivK<sub>A, Π</sub><sup>eav</sup>.
Buscamos encontrar um esquema criptográfico EAV-seguro para adversários que não estão limitados à mensagens de tamanho fixo. Como dado pelo enunciado, **Enc** está limitado à mensagens de tamanho no máximo l(n). Vamos construir um esquema $\Pi$' = (Gen', Enc', Dec') seguro para a definição 3.8 que aceite mensagens de tamanhos diferentes como entrada, com base no esquema $\Pi$ dado pelo enunciado. Para isso, precisamos construir os três algoritmos base do esquema. (1) O algoritmo **Gen'** é idêntico ao algoritmo **Gen** original. (2) O algoritmo **Enc'** primeiramente realiza um padding na mensagem *m* de entrada, tal que *m'* $\coloneqq$ 0<sup>l(n) - |m| - 1</sup>||1||*m*, e depois encripta *m'* exatamente da mesma forma que **Enc**. Assim, independentemente do tamanho da mensagem na entrada, qualquer objeto encriptado sempre terá o mesmo tamanho l(n). Como, por definição, **Enc** é um algoritmo de encriptação válido para mensagens de mesmo tamanho, **Enc'** também é. (3) O algoritmo **Dec'** aplica a decriptação exatamente igual à  **Dec** e depois separa a mensagens
resultante em suas partes 0<sup>x</sup>||1||m. Aqui torna-se perceptível a necessidade do bit 1 no final do padding, já que sem ele, seria impossível reconhecer o fim do padding / início da mensagem. Desse modo, temos uma construção de um esquema criptográfico baseado em $\Pi$ que é EAV-seguro mesmo aceitando mensagens de tamanhos diferentes, ou seja, $\Pi$ é seguro $\implies$ $\Pi$' é seguro.

Para provarmos que $\Pi$' é EAV-seguro, vamos nos basear na contrapositiva de sua construção, ou seja, $\Pi$' não é seguro $\implies$ $\Pi$ não é seguro. Se $\Pi$' não é seguro, significa que existe um adversário *A*' tal que P[PrivK<sub>A', Π'</sub><sup>eav</sup>(n)] > 1/2 + *negl*(n), ou seja, *A'* consegue distinguir entre a encriptação de duas mensagens *m0* e *m1* de tamanho arbitrário < l(n). Assim, um adversário *A* consegue quebrar o esquema $\Pi$ com a seguinte estratégia: ao gerar duas mensagem *m0* e *m1* de tamanhos iguais, basta realizar um padding nelas assim como o feito pelo algoritmo **Enc'**, encriptá-las com **Enc** normalmente e devolver o mesmo valor de *b'* que *A'* ao receber ambos ciphertexts gerados. Se *A'* consegue distingui-los com probabilidade não insignificante maior do que 1/2, significa que *A* também, e a prova está finalizada.

## 3.4) Prove the equivalence of Definition 3.8 and Definition 3.9.
P[PrivK<sub>A, Π<sub><sup>eav<sup>(n) = 1] == P<sub>b ∈ {0,1}</sub>[out(PrivK<sub>A, Π</sub><sup>eav<sup>(n, b)) = b] == 1/2 * P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 0] + 1/2 * P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1] == 1/2 * (1 - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1]) + 1/2 * P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1] == 1/2 * (1 - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1] + P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1]) $\le$ 1/2 + *negl*(n) $\implies$ (1 - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1] + P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1]) $\le$ 1 + 2*negl*(n) $\implies$ P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1] - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1] $\le$ 2*negl*(n) $\implies$ |P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1] - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1]| $\le$ *negl<sub>t</sub>*(n)

## 3.5) Define *G*(s) = *s*||*s*. Describe and analyze an attack showing that *G* is not a pseudorandom generator.
Buscamos definir um adversário *A* PPT capaz de distinguir entre uma string *r* escolhida uniformemente e uma string *s'* = *G*(s). Note que *s'* tem tamanho 2n (onde *n* é o tamanho de *s*) e é da forma *s<sub>1</sub>**s<sub>2</sub>*...*s<sub>n</sub>**s<sub>1</sub>**s<sub>2</sub>*...*s<sub>n</sub>*. Para distinguir entre ambas strings, *A* precisa apenas passar pela string recebida *t* e analisar se a sua primeira metade (bits de 1 até *n*) são iguais à segunda metade (bits de *n*+1 até 2*n*). Caso positivo, devolve 1 (afirmando que *t* = *s'), e caso contrário, devolve 0 (afirmando que *t* = *r*). Tal ataque funcionará com probabilidade não insignificante, já que toda string gerada por *G* terá tal formato, enquanto a probabilidade de uma string uniforme assumir tal forma é de 2<sup>-n</sup>. Portanto: P[*A*(*G*(*s*))) = 1] = 1 e P[*A*(*r*)) = 1] = 2<sup>-n</sup> $\implies$ |P[*A*(*G*(*s*))) = 1] - P[*A*(*r*)) = 1]| > *negl*(n), provando que *G* não é um gerador pseudoaleatório.

## 3.7) Let |*G*(s) = *l*(|s|) for some *l*. Provide a definition of a pseudorandom generator based on this experiment, and prove that your definition is equivalent to Definition 3.14.
Podemos formular uma definição semelhante às de segurança, ou seja: um algoritmo *G* é um gerador pseudoaleatório se $\forall$ *n* e $\forall$ *s* $\in$ {0, 1}<sup>n</sup>, qualquer adversário *A* PPT tem que P[PRG<sub>A, G</sub>(*n*) = 1] $\le$ 1/2 + *negl*(n).
A prova de equivalência é extremamente semelhante à prova de equivalência entre a Definição 3.8 e a Definição 3.9 feita no exercício 3.4)

## 3.9) Consider a notion of indistinguishable encryption for multiple distinct messages, i.e., where a scheme need not hide whether the same message is encrypted twice. (a) Modify Definition 3.18 to obtain a suitable definition of the above. (b) Show that Construction 3.17 does not satisfy your definition. (c) Give a construction of a deterministic (stateless) encryption scheme that satisfies your definition.
(a) A definição modificada altera apenas o experimento de indistinguibilidade, sendo agora um experimento de multiplas encriptações PrivK<sub>A, Π</sub><sup>mult</sup>(n), porém as mensagens de uma mesma lista *M<sub>i</sub>* devem ser diferentes.
(b) A construção 3.17 não é segura para a definição acima, ou seja, não tem múltiplas encriptações indistinguíveis de mensagens distintas. Um adversário *A* capaz de explicitar tal falha de segurança se baseia na ideia de que a mesma mensagem pode estar presente em listas diferentes. Assim, enviar uma mesma mensagem *m* que pertence à ambas listas na mesma posição para o experimento implica em receber com 100% de probabilidade a encriptação *c* associada. Ao realizar *m* $\oplus$ *c*, descobre-se *G*(*k*). Para descobrir o bit *b* selecionado pelo experimento, basta agora enviar um segundo par de mensagens, em que ambas diferem apenas no último bit. Por ter *G*(*k*) em mãos, resta checar o estado do último bit do ciphertext recebido e compará-lo de acordo com o $\oplus$ do último bit de *G*(*k*) e das mensagens enviadas. Assim, realizando o experimento com apenas duas mensagens, a construção 3.17 mostra se insegura.
(c) Para satisfazer a definição acima com uma construção de um esquema criptográfico determinístico e *stateless*, basta utilizar uma PRP em Enc, ou seja, fazendo Enc(m) = *F*<sub>k</sub>(m), onde *F*<sub>k</sub> é uma PRP. O principal problema da Construção 3.17 é que é possível retirar informações das mensagens a partir da sua encriptação. A introdução de permutações pseudoaleatórias na construção introduz difusão, e acaba com o problema de, por exemplo, diferenciar encriptações pelos bits finais como na alternativa acima.

## 3.10) Prove *unconditionally* the existence of a pseudorandom function *F*: {0, 1}<sup>*</sup> x {0, 1}<sup>*</sup> $\rightarrow$ {0, 1} with *l<sub>key</sub>*(*n*) = *n* and *l<sub>in</sub>*(*n*) = log *n*
É notável que log *n* se refere justamente ao tamanho da representação binária de *n*. Portanto, é possível construir uma função *F*: {0, 1}<sup>n</sup> x {0, 1}<sup>log n</sup> $\rightarrow$ {0, 1} em que *F*<sub>k</sub>(i) devolve o *i*-ésimo bit de *k*. Como *k* é uma chave escolhida uniformemente, a saída de *F* é também uniforme, tornando-à uma função verdadeiramente aleatória.
