# Respostas

## Prova teorema pós 3.25 (pág. 78)
Objetivamos provar que podemos construir uma função pseudoaleatória (PRF) *F* a partir de um gerador pseudoaleatório (PRG) *G*. Portanto, suponhamos que *G* seja um gerador pseudoaleatório válido. Por definição, |P[D(G(k)) = 1] - P[D(r) = 1] $\le$ negl, ou seja, para qualquer diferenciador *D* PPT, a probabilidade de *D* conseguir diferenciar G(k) de uma string uniforme aleatória é insignificante. Porém, vamos provar que se existe um diferenciador *D'* que consegue diferenciar *Fk* de uma função verdadeiramente aleatória, podemos utilizá-lo para construir um diferenciador *D* que distingue entre *G(k)* e uma string aleatória.
O diferenciador *D* funciona da seguinte forma: dado uma string *s*, com |*s*| = *n* * 2<sup>t(n)</sup>, dada pela entrada, *D* busca descobrir se *s* foi amostrada de uma distribuição uniforme ou se foi gerada por G(k). Como dado pelo parágrafo, *Fk* é interpretada como uma lookup-table de 2<sup>t(n)</sup> colunas com strings de tamanho *n* em cada uma. Portanto, é possível construir uma nova função *F'* com base em *s*, em que *F'(i)* equivale ao *i*-ésimo bloco de tamanho *n* de *s*. Assim, *D* chama *D'* passando *F'(i)* como parâmetro e devolve o mesmo resultado que *D'*. Se *D'* devolver 0, significa que a função *F'(i)* não é aleatória, e 1 caso contrário. Assim, como *F'(i)* foi construída com base na string *s*, sabemos que ambas estruturas possuem as mesmas propriedades, e que, portanto, *D* responderia corretamente toda vez que *D'* respondesse corretamente. Porém, como G é um gerador pseudoaleatório, não é possível existir um *D'* que diferencie *F'* de uma função verdadeiramente aleatória com probabilidade maior que insignificante, já que implicaria em uma contradição com a definição de G. Portanto, conclui-se que *F* gerada por G é pseudoaleatória.

## 3.1) 
1. Seja q(n) um polinômio qualquer, tal que *negl<sub>1</sub>(n)* < 1/(2 * q(n)), para qualquer *n* > *N<sub>1</sub>* e  *negl<sub>2</sub>(n)* < 1/(2 * q(n)), para qualquer *n* > *N<sub>2</sub>*. Ambas funções são insignificantes, pois respeitam as condições de definição de tal classe de funções, já que q(n) é um polinômio qualquer. Definimos juntamente *N<sub>3</sub>* como max(*N<sub>1</sub>*, *N<sub>2</sub>*). Desse modo: *negl<sub>1</sub>(n)* < 1/(2 * q(n)) e *negl<sub>2</sub>(n)* < 1/(2 * q(n)), para qualquer *n* > *N<sub>3</sub>*, implicando que *negl<sub>1</sub>(n)* + *negl<sub>2</sub>(n)* < 1/(2 * q(n)) + 1/(2 * q(n)) = 1/q(n). Como *negl<sub>3</sub>(n)* = *negl<sub>1</sub>(n)* + *negl<sub>2</sub>(n)* por definição, segue que *negl<sub>3</sub>(n) < 1/q(n)* para qualquer *n* < *N<sub>3</sub>* e que, portanto, é também uma função insignificante.
2. Seja q(n) um polinômio qualquer, tal que *negl<sub>1</sub>(n)* < 1/(p(n) * q(n)) para qualquer *n* > *N<sub>1</sub>*. Válido, pois, por propriedade de polinômios, se p(n) e q(n) são polinômios, p(n) * q(n) também é. Assim, p(n) * *negl<sub>1</sub>(n)* < p(n) * 1/(p(n) * q(n)) = 1/q(n), para qualquer *n* > *N*. Consequentemente, *negl<sub>4</sub>(n)* = p(n) * *negl<sub>1</sub>(n)* < 1/q(n) para qualquer *n* > *N* e, portanto, também é uma função insignificante.

## 3.2) 
Seja q(n) o tamanho máximo possível de ciphertext gerado quando **Enc** é utilizado para encriptar um único bit. Desse modo, basta criarmos um adversário *A* que seleciona duas mensagens *m0* e *m1*, tal que |*m0*| = 1 e |*m1*| = q(n) + x, com x > 0, ou seja, *m0* consiste em um único bit e *m1* consiste em uma mensagem maior que q(n). Dado um ciphertext de desafio *c*, sabe-se então que *b* = 0 $\iff$ |*c*| $\le$ q(n) e *b* = 1 $\iff$ |*c*| > q(n) sempre que as mensagens dadas para o experimento seguem o formato estipulado. Consequentemente, basta o adversário *A* devolver *b'* conforme as condições descritas que será bem sucedido com probabilidade > 1/2 + *negl*(n)

## 3.3) 
Buscamos encontrar um esquema criptográfico EAV-seguro para adversários que não estão limitados à mensagens de tamanho fixo. Como dado pelo enunciado, **Enc** está limitado à mensagens de tamanho no máximo l(n). Vamos construir um esquema $\Pi$' = (Gen', Enc', Dec') seguro para a definição 3.8 que aceite mensagens de tamanhos diferentes como entrada, com base no esquema $\Pi$ dado pelo enunciado. Para isso, precisamos construir os três algoritmos base do esquema. (1) O algoritmo **Gen'** é idêntico ao algoritmo **Gen** original. (2) O algoritmo **Enc'** primeiramente realiza um padding na mensagem *m* de entrada, tal que *m'* $\coloneqq$ 0<sup>l(n) - |m| - 1</sup>||1||*m*, e depois encripta *m'* exatamente da mesma forma que **Enc**. Assim, independentemente do tamanho da mensagem na entrada, qualquer objeto encriptado sempre terá o mesmo tamanho l(n). Como, por definição, **Enc** é um algoritmo de encriptação válido para mensagens de mesmo tamanho, **Enc'** também é. (3) O algoritmo **Dec'** aplica a decriptação exatamente igual à  **Dec** e depois separa a mensagens
resultante em suas partes 0<sup>x</sup>||1||m. Aqui torna-se perceptível a necessidade do bit 1 no final do padding, já que sem ele, seria impossível reconhecer o fim do padding / início da mensagem. Desse modo, temos uma construção de um esquema criptográfico baseado em $\Pi$ que é EAV-seguro mesmo aceitando mensagens de tamanhos diferentes, ou seja, $\Pi$ é seguro $\implies$ $\Pi$' é seguro.

Para provarmos que $\Pi$' é EAV-seguro, vamos nos basear na contrapositiva de sua construção, ou seja, $\Pi$' não é seguro $\implies$ $\Pi$ não é seguro. Se $\Pi$' não é seguro, significa que existe um adversário *A*' tal que P[PrivK<sub>A', Π'</sub><sup>eav</sup>(n)] > 1/2 + *negl*(n), ou seja, *A'* consegue distinguir entre a encriptação de duas mensagens *m0* e *m1* de tamanho arbitrário < l(n). Assim, um adversário *A* consegue quebrar o esquema $\Pi$ com a seguinte estratégia: ao gerar duas mensagem *m0* e *m1* de tamanhos iguais, basta realizar um padding nelas assim como o feito pelo algoritmo **Enc'**, encriptá-las com **Enc** normalmente e devolver o mesmo valor de *b'* que *A'* ao receber ambos ciphertexts gerados. Se *A'* consegue distingui-los com probabilidade não insignificante maior do que 1/2, significa que *A* também, e a prova está finalizada.

## 3.4) 
P[PrivK<sub>A, Π</sub><sup>eav</sup>(n) = 1] == P<sub>b ∈ {0,1}</sub>[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, b)) = b] == 
== 1/2 * P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 0] + 1/2 * P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1] == 
== 1/2 * (1 - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1]) + 1/2 * P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1] == 1/2 * (1 - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1] + P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1]) $\le$ 
$\le$ 1/2 + *negl*(n)
$\implies$ (1 - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1] + P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1]) $\le$ 1 + 2*negl*(n) 
$\implies$ P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1] - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1] $\le$ 2*negl*(n)
$\implies$ |P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 1)) = 1] - P[out(PrivK<sub>A, Π</sub><sup>eav</sup>(n, 0)) = 1]| $\le$ *negl<sub>t</sub>*(n)

## 3.5) 
