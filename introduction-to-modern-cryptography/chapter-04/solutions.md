# Respostas

## 4.1) Consider an extension of the definition of secure message authentication where the adversary is provided with both a Mac and a Vrfy oracle. (a) Provide a formal definition of security for this case. (b) Assume $\Pi$ is a deterministic MAC using canonical verification that satisfies Definition 4.2. Prove that $\Pi$ also satisfies your definition from part (a).
(a) Temos uma nova definição para o experimento Mac-pforge<sub>A, Π</sub>(*n*): funciona basicamente igual ao experimento Mac-forge, mas o adversário também é dado acesso a um oráculo Vrfy<sub>k</sub>. Assim, um código de autenticação de mensagem $\Pi$ = Gen, Vrfy, Mac) é seguro se, para todo adversário *A* PPT, existe uma função insignificante *negl* tal que P[Mac-pforge<sub>A, Π</sub>(*n*) = 1] $\le$ *negl*. Isso mostra que a definição de segurança não é alterada, exceto pelo fato de que se refere ao experimento Mac-pforge ao invés de Mac-forge.
A condição de segurança não precisa ser alterada. Acesso a um oráculo Vrfy<sub>k</sub>garante a qualquer adversário *A* que sua tentativa de resposta (*m*, *t*) é válida. Porém, se o espaço amostral de tags *t* é exponencial, como *A* é PPT, só pode realizar um número polinomial de consultas. Desse modo, a probabilidade de *A* encontrar um par (*m*, *t*) válido é insignificante (consultas polinomiais sobre um espaço amostral exponencial). Conclui-se, portanto, que ter acesso ao oráculo **Vrfy** garante ao adversário uma chance insignificante de ter certeza de que seu par (*m*, *t*) é válido, não alterando expressivamente, portanto, suas probabilidades de sucesso.

(b) Temos um esquema $\Pi$ = (Gen, Mac, Vrfy) baseado em verificação canônica seguro e buscamos provar que $\Pi$ é seguro perante a definição acima. Vamos provar pela contrapositiva, ou seja, se $\Pi$ não é seguro para a definição em (a), $\Pi$ não é seguro conforme a definição 4.2. Seja *A*' um adversário PPT sujeito ao experimento **Mac-pforge**. Se $\Pi$ não é seguro para a definição em (a), significa que P[Mac-pforge<sub>A', Π</sub>(*n*) = 1] > *negl*, ou seja, *A*' consegue encontrar um par (*m*, *t*) válido com probabilidade significante dado um número polinomial de consultas. Desse modo, podemos construir um adversário *A* baseado em *A*' capaz de quebrar $\Pi$ para a definição 4.2. Quando sujeito ao experimento Mac-forge(*n*), basta *A* realizar uma chamada de *A*' e devolver o mesmo par (*m*, *t*) recebido. Como *A*' é PPT, *A* também é. Para mais, temos como garantia que *A*' devolverá um par (*m*, *t*) tal que Vrfy<sub>k</sub>(*m*) = 1, já que, caso contrário, não teria sido bem sucedido no experimento. Desse modo, *A* terá acesso a uma par (*m*, *t*) válido (Mac(*m*) = *t*), tal que a verificação da mensagem *m* é válida e, como não foi feita nenhuma outra consulta ao seu oráculo Mac<sub>k</sub>(.), *m* $\notin$ *Q*. Consequentemente, P[Mac-forge<sub>A, Π</sub>(*n*) = 1] = P[Mac-pforge<sub>A', Π</sub>(*n*) = 1] > *negl*, concluindo a prova do proposto. Como $\Pi$ é seguro conforme a definição 4.2, temos que *A* é impossível de ser construído.

## 4.2) Assume secure MACs exist. Give a construction of  MAC that is secure with respect to Definition 4.2 but that is not secure when the adversary is additionally given access to a Vrfy oracle (cf. the previous exercise).
Seja $\Pi$ = (**Gen**, **Mac**, **Vrfy**) um MAC seguro conforme a definição 4.2. Podemos construir um novo MAC $\Pi$' = (**Gen**, **Mac**', **Vrfy**') da seguinte forma: (a) **Mac'<sub>k</sub>(*m*)** devolve [0, Mac<sub>k</sub>(*m*), 0, 0] = [0, *t*, 0, 0]. (b) Vrfy'<sub>k</sub>(*m*, [*c*, *t*, *i*, *b*]) possui dois modos de funcionamento: se *c* = 0, devolve 1 $\iff$ Vrfy<sub>k</sub>(*m*) == *t*; se *c* = 1, devolve 1 $\iff$ Vrfy<sub>k</sub>(*m*) == *t* e se o *i*-ésimo bit de *k* == *b*.
$\Pi$' é seguro para a definição 4.2, já que o seu algoritmo Mac'<sub>k</sub>(*m*) funciona praticamente igual ao original, tal que a única diferença, associada à adição dos 3 zeros, não melhora nem piora a segurança. Porém, quando sujeito a um experimento Mac-pforge como definido no exercício anterior, $\Pi$' se torna vulnerável a partir do seguinte ataque: primeiramente, o adversário *A* calcula Mac'<sub>k</sub>(*m*) para uma mensagem *m* arbitrária, obtendo uma tag *t'* = [0, *t*, 0, 0] válida; posteriormente, avalia Vrfy'<sub>k</sub>(*m*, [1, *t*, *i*, 0]) com *i* variando de 1 à *n*. Como *t* é uma tag válida, *A* sabe que a saída de cada chamada da função está associada diretamente ao valor do *i*-ésimo bit da chave, tal que no final do processo, terá a chave completa. Basta então calcular a parte *t*<sub>f</sub> para uma mensagem *m*<sub>f</sub> sem chamar Mac'<sub>k</sub>(*m<sub>f</sub>*) e terá forjado uma tag válida para uma mensagem selecionada.

# 4.3) Prove Proposition 4.4 (*Let $\Pi$ = (Gen, Mac, Vrfy) be a secure (deterministic) MAC that uses canonical verification. Then $\Pi$ is strongly secure.*)
Seja $\Pi$ = (**Gen**, **Mac**, **Vrfy**) um MAC seguro e determinístico que utiliza verificação canônica. Buscamos provar que $\Pi$ é fortemente seguro. Suponhamos, portanto, que $\Pi$ não é fortemente seguro. Isso significa que existe um adversário *A* tal que P[Mac-sforge<sub>A, Π</sub>(*m*) = 1] > *negl*, implicando que *A* devolveu um par (*m*, *t*) $\notin$ *Q*. Tal evento só pode ocorrer caso (1) *m* $\notin$ *Q* ou (2) *t* $\notin$ *Q*. O caso (2) implica que a mensagem *m* tem mais de uma tag válida, o que, por definição, significa que $\Pi$ não é determinístico e que $\Pi$ não realiza verificação canônica, representando uma contradição. Já o evento (1) implica que *A* gerou uma tag válida para a mensagem *m* sem sequer consultar o oráculo Mac<sub>k</sub>(.). Porém, $\Pi$ é seguro por definição, então *A* não é capaz de realizar tal fato com probabilidade maior do que insignificante. Portanto, tem-se que $\Pi$ é fortemente seguro, e o proposto segue.

# 4.4 Assume secure MACs exist. Prove that there exists a MAC that is secure (Definition 4.2) but is *not* strongly secure (Definition 4.3).
