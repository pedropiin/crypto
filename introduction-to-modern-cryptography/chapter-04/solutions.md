# Respostas

## 4.1) Consider an extension of the definition of secure message authentication where the adversary is provided with both a Mac and a Vrfy oracle. (a) Provide a formal definition of security for this case. (b) Assume $\Pi$ is a deterministic MAC using canonical verification that satisfies Definition 4.2. Prove that $\Pi$ also satisfies your definition from part (a).
(a) Temos uma nova definição para o experimento Mac-pforge<sub>A, Π</sub>(*n*): funciona basicamente igual ao experimento Mac-forge, mas o adversário também é dado acesso a um oráculo Vrfy<sub>k</sub>. Assim, um código de autenticação de mensagem $\Pi$ = Gen, Vrfy, Mac) é seguro se, para todo adversário *A* PPT, existe uma função insignificante *negl* tal que P[Mac-pforge<sub>A, Π</sub>(*n*) = 1] $\le$ *negl*. Isso mostra que a definição de segurança não é alterada, exceto pelo fato de que se refere ao experimento Mac-pforge ao invés de Mac-forge.
A condição de segurança não precisa ser alterada. Acesso a um oráculo Vrfy<sub>k</sub>garante a qualquer adversário *A* que sua tentativa de resposta (*m*, *t*) é válida. Porém, se o espaço amostral de tags *t* é exponencial, como *A* é PPT, só pode realizar um número polinomial de consultas. Desse modo, a probabilidade de *A* encontrar um par (*m*, *t*) válido é insignificante (consultas polinomiais sobre um espaço amostral exponencial). Conclui-se, portanto, que ter acesso ao oráculo **Vrfy** garante ao adversário uma chance insignificante de ter certeza de que seu par (*m*, *t*) é válido, não alterando expressivamente, portanto, suas probabilidades de sucesso.

(b) Temos um esquema $\Pi$ = (Gen, Mac, Vrfy) baseado em verificação canônica seguro e buscamos provar que $\Pi$ é seguro perante a definição acima. Vamos provar pela contrapositiva, ou seja, se $\Pi$ não é seguro para a definição em (a), $\Pi$ não é seguro conforme a definição 4.2. Seja *A*' um adversário PPT sujeito ao experimento **Mac-pforge**. Se $\Pi$ não é seguro para a definição em (a), significa que P[Mac-pforge<sub>A', Π</sub>(*n*) = 1] > *negl*, ou seja, *A*' consegue encontrar um par (*m*, *t*) válido com probabilidade significante dado um número polinomial de consultas. Desse modo, podemos construir um adversário *A* baseado em *A*' capaz de quebrar $\Pi$ para a definição 4.2. Quando sujeito ao experimento Mac-forge(*n*), basta *A* realizar uma chamada de *A*' e devolver o mesmo par (*m*, *t*) recebido. Como *A*' é PPT, *A* também é. Para mais, temos como garantia que *A*' devolverá um par (*m*, *t*) tal que Vrfy<sub>k</sub>(*m*) = 1, já que, caso contrário, não teria sido bem sucedido no experimento. Desse modo, *A* terá acesso a uma par (*m*, *t*) válido (Mac(*m*) = *t*), tal que a verificação da mensagem *m* é válida e, como não foi feita nenhuma outra consulta ao seu oráculo Mac<sub>k</sub>(.), *m* $\notin$ *Q*. Consequentemente, P[Mac-forge<sub>A, Π</sub>(*n*) = 1] = P[Mac-pforge<sub>A', Π</sub>(*n*) = 1] > *negl*, concluindo a prova do proposto. Como $\Pi$ é seguro conforme a definição 4.2, temos que *A* é impossível de ser construído.

## 4.2) Assume secure MACs exist. Give a construction of  MAC that is secure with respect to Definition 4.2 but that is not secure when the adversary is additionally given access to a Vrfy oracle (cf. the previous exercise).
Seja $\Pi$ = (**Gen**, **Mac**, **Vrfy**) um MAC seguro conforme a definição 4.2. Podemos construir um novo MAC $\Pi$' = (**Gen**, **Mac**', **Vrfy**') da seguinte forma: (a) **Mac'<sub>k</sub>(*m*)** devolve [0, Mac<sub>k</sub>(*m*), 0, 0] = [0, *t*, 0, 0]. (b) Vrfy'<sub>k</sub>(*m*, [*c*, *t*, *i*, *b*]) possui dois modos de funcionamento: se *c* = 0, devolve 1 $\iff$ Vrfy<sub>k</sub>(*m*) == *t*; se *c* = 1, devolve 1 $\iff$ Vrfy<sub>k</sub>(*m*) == *t* e se o *i*-ésimo bit de *k* == *b*.
$\Pi$' é seguro para a definição 4.2, já que o seu algoritmo Mac'<sub>k</sub>(*m*) funciona praticamente igual ao original, tal que a única diferença, associada à adição dos 3 zeros, não melhora nem piora a segurança. Porém, quando sujeito a um experimento Mac-pforge como definido no exercício anterior, $\Pi$' se torna vulnerável a partir do seguinte ataque: primeiramente, o adversário *A* calcula Mac'<sub>k</sub>(*m*) para uma mensagem *m* arbitrária, obtendo uma tag *t'* = [0, *t*, 0, 0] válida; posteriormente, avalia Vrfy'<sub>k</sub>(*m*, [1, *t*, *i*, 0]) com *i* variando de 1 à *n*. Como *t* é uma tag válida, *A* sabe que a saída de cada chamada da função está associada diretamente ao valor do *i*-ésimo bit da chave, tal que no final do processo, terá a chave completa. Basta então calcular a parte *t*<sub>f</sub> para uma mensagem *m*<sub>f</sub> sem chamar Mac'<sub>k</sub>(*m<sub>f</sub>*) e terá forjado uma tag válida para uma mensagem selecionada.

## 4.3) Prove Proposition 4.4 (*Let $\Pi$ = (Gen, Mac, Vrfy) be a secure (deterministic) MAC that uses canonical verification. Then $\Pi$ is strongly secure.*)
Seja $\Pi$ = (**Gen**, **Mac**, **Vrfy**) um MAC seguro e determinístico que utiliza verificação canônica. Buscamos provar que $\Pi$ é fortemente seguro. Suponhamos, portanto, que $\Pi$ não é fortemente seguro. Isso significa que existe um adversário *A* tal que P[Mac-sforge<sub>A, Π</sub>(*m*) = 1] > *negl*, implicando que *A* devolveu um par (*m*, *t*) $\notin$ *Q*. Tal evento só pode ocorrer caso (1) *m* $\notin$ *Q* ou (2) *t* $\notin$ *Q*. O caso (2) implica que a mensagem *m* tem mais de uma tag válida, o que, por definição, significa que $\Pi$ não é determinístico e que $\Pi$ não realiza verificação canônica, representando uma contradição. Já o evento (1) implica que *A* gerou uma tag válida para a mensagem *m* sem sequer consultar o oráculo Mac<sub>k</sub>(.). Porém, $\Pi$ é seguro por definição, então *A* não é capaz de realizar tal fato com probabilidade maior do que insignificante. Portanto, tem-se que $\Pi$ é fortemente seguro, e o proposto segue.

## 4.4) Assume secure MACs exist. Prove that there exists a MAC that is secure (Definition 4.2) but is *not* strongly secure (Definition 4.3).
Buscamos definir um MAC seguro conforme a definição 4.2, mas que não seja fortemente seguro. Isso significa que P[Mac-forge<sub>A, Π</sub>(*m*) = 1] $\le$ *negl* e P[Mac-sforge<sub>A, Π</sub>(*m*) = 1] > *negl*. Em outras palavras, qualquer adversário *A* PPT sujeito à um oráculo para a função Mac<sub>k</sub>(.) de tal construção não consegue gerar uma tag *t* válida para uma mensagem *m* ainda não consultada/avaliada pelo oráculo, mas consegue gerar uma nova tag *t<sub>2</sub>* para uma mensagem já consultada *m*, tal que *t<sub>2</sub>* $\neq$ *t*. Trivialmente temos que o MAC em questão não pode ser determinístico, já que assim seria impossível gerar múltiplas tags distintas para uma mesma mensagem arbitrária. Seja $\Pi$ = (Gen, Mac, Vrfy) um MAC seguro conforme a definição 4.2. Podemos construir o MAC $\Pi$' = (Gen, Mac', Vrfy') para mensagens de tamanho n/2, tal que Mac'(*m*) devolve *t* = [Mac([*c*]||*m*), *c*], sendo *c* a representação de um contador com n/2 bits; e Vrfy'(*m*, *t*) funciona semelhantemente a Vrfy(*m*, *t*), levando em consideração o contador. Assim, qualquer adversário *A* PPT, ao calcular o MAC de uma mensagem *m* mais de uma vez, terá duas tags diferentes, devido ao contador, contrariando, portanto, a definição de segurança forte. Desse modo, o enunciado segue.

## 4.5) Consider the following MAC for messages of length *l*(*n*) = 2*n* - 2 using a pseudorandom function *F*: On input a message *m<sub>0</sub>*||*m<sub>1</sub>* (with |*m<sub>0</sub>*| = |*m<sub>1</sub>*| = *n* - 1) and key *k* $\in$ {0, 1}<sup>n</sup>, algorithm Mac outputs *t* = *F*<sub>k</sub>(0||*m<sub>0</sub>*)||*F<sub>k</sub>*(1||*m<sub>1</sub>*). Algorithm Vrfy is defined in the natural way. Is this MAC secure? Prove you answer.
O MAC em questão não é seguro e pode ser visto pelo seguinte ataque. Seja *A* um adversário qualquer PPT. *A* primeiramente seleciona uma mensagem *m* $\in$ $\mathcal{M}$ arbitrária tal que |*m*| = *n* - 1 e calcula *t<sub>1</sub>* = Mac(*m*||1<sup>n-1</sup>) e *t<sub>2</sub>* = Mac(0<sup>n-1</sup>||*m*). Expandindo, *t<sub>1</sub>* = *F*<sub>k</sub>(0||*m*)||*F<sub>k</sub>*(1<sup>n</sup>) e *t<sub>2</sub>* = *F*<sub>k</sub>(0<sup>n</sup>)||*F<sub>k</sub>*(1||*m*), tal que com os últimos *n* bits de *t<sub>1</sub>*, obtém-se *F*<sub>k</sub>(1<sup>n</sup>) = x<sub>1</sub> e com os primeiros *n* bits de *t<sub>2</sub>*, obtém-se *F*<sub>k</sub>(0<sup>n</sup>) = x<sub>2</sub>. Basta agora *A* selecionar a mensagem *m<sub>f</sub>* = 0<sup>n-1</sup>||1<sup>n-1</sup> e devolver o par (*m*<sub>f</sub>, *t* = x<sub>1</sub>||x<sub>2</sub>) como resposta final para o desafio, que haverá quebrado a segurança da construção. Portanto, o enunciado segue.

## 4.6) Let *F* be a pseudorandom function. Show that each of the following MACs is insecure, even if used to authenticate fixed-length messages. (In each case Gen output a uniforme *k* $\in$ {0, 1}<sup>n</sup>; we let [*i*] denote an *n*/2-bit encoding of the integer *i*.) (a) To authenticate a message *m* = *m<sub>1</sub>*,...,*m<sub>l</sub>*, where *m<sub>i</sub>* $\in$ {0, 1}<sup>n</sup>, compute *t* $\coloneqq$ *F*<sub>k</sub>(*m<sub>1</sub>*) $\oplus$ ... $\oplus$ *F*<sub>k</sub>(*m<sub>l</sub>*). (b) To authenticate a message *m* = *m<sub>1</sub>*,...,*m*<sub>l</sub>, where *m<sub>i</sub>* $\in$ {0, 1}<sup>n/2</sup>, compute *t* $\coloneqq$ *F*<sub>k</sub>([1]||*m<sub>1</sub>*) $\oplus$ ... $\oplus$ *F*<sub>k</sub>([*l*]||*m<sub>l</sub>*). (c) To authenticate a message *m* = *m<sub>1</sub>*,...,*m*<sub>l</sub>, where *m<sub>i</sub>* $\in$ {0, 1}<sup>n/2</sup>, choose uniforme *r* $\in$ {0, 1}<sup>n</sup>, compute *t* $\coloneqq$ *F*<sub>k</sub>(*r*) $\oplus$ F*<sub>k</sub>([1]||*m<sub>1</sub>*) $\oplus$ ... $\oplus$ *F*<sub>k</sub>([*l*]||*m<sub>l</sub>*), and let the tag be [*r*, *t*].
(a) Seja *A* um adversário PPT qualquer. Basta *A* devolver o par (*m*, *t*) = (*m<sub>t</sub>*||*m<sub>t</sub>*, 0<sup>n</sup>), sendo *m*<sub>t</sub> $\in$ $\mathcal{M}$ uma mensagem arbitrária de tamanho = *n* bits. Desse modo, caso avaliada na função *Mac*<sub>k</sub>(.), a tag devolvida seria *F*<sub>k</sub>(*m<sub>t</sub>*) $\oplus$ *F*<sub>k</sub>(*m<sub>t</sub>*) = 0. Assim, *A* é capaz de calcular uma tag em qualquer mensagem arbitrária ainda não avaliada.

(b) Seja *A* um adversário PPT qualquer. Para realizar o ataque, *A* avalia x<sub>1</sub> = Mac(0<sup>n</sup>) = *F*<sub>k</sub>([1]||0<sup>n/2</sup>) $\oplus$ *F*<sub>k</sub>([2]||0<sup>n/2</sup>) e x<sub>3</sub> = Mac(0<sup>2n</sup>) = *F*<sub>k</sub>([1]||0<sup>n/2</sup>) $\oplus$ *F*<sub>k</sub>([2]||0<sup>n/2</sup>) $\oplus$ *F*<sub>k</sub>([3]||0<sup>n/2</sup>) $\oplus$ *F*<sub>k</sub>([4]||0<sup>n/2</sup>), calculando posteriormente x<sub>2</sub> = x<sub>3</sub> $\oplus$ x<sub>1</sub> = *F*<sub>k</sub>([3]||0<sup>n/2</sup>) $\oplus$ *F*<sub>k</sub>([4]||0<sup>n/2</sup>). Deve também avaliar *x<sub>4</sub>* = Mac(1<sup>n</sup>) = *F*<sub>k</sub>([1]||1<sup>n/2</sup>) $\oplus$ *F*<sub>k</sub>([2]||1<sup>n/2</sup>). Por fim, *A* devolve como resposta do experimento o par (*m* = 1<sup>n</sup>||0<sup>n</sup>, *t* = x<sub>2</sub> $\oplus$ x<sub>4</sub>) que terá calculado de forma bem sucedida a tag de uma mensagem nova, isto é, ainda não avaliada. Todos os saltos aritméticos podem ser discorridos, mas aqui não foram para simplificar a resolução. Assim, o enunciado segue.

(c) Seja *A* um adversário PPT qualquer. O atacante pode ser bem-sucedido ao devolver o par [*m* = 0<sup>n/2</sup>, *t* = (*r* = [1]||0<sup>n/2</sup>, *t* = 0<sup>n</sup>)]. Simulando as chamadas do oráculo dessa forma, teríamos que Mac(*m*) = *F<sub>k</sub>*(*r*) $\oplus$ *F<sub>k</sub>*(*m*) = *F<sub>k</sub>*([1]||0<sup>n/2</sup>) $\oplus$ *F<sub>k</sub>*([1]||0<sup>n/2</sup>) = 0<sup>n</sup> = *t*, demonstrando que o par devolvido é uma simulação válida.

## 4.7) Let *F* be a pseudorandom function. Show that the following MAC for messages of length 2*n* is insecure: Gen outputs a uniform *k* $\in$ {0, 1}<sup>n</sup>. To authenticate a message *m<sub>1</sub>*||*m<sub>2</sub>* with |*m<sub>1</sub>*| = |*m<sub>2</sub>*| = *n*, compute the tag *F<sub>k</sub>*(*m<sub>1</sub>*)||*F<sub>k</sub>*(*F<sub>k</sub>*(*m<sub>2</sub>*)).
Seja *A* um adversário PPT qualquer. Para realizar um ataque válido, *A* primeiramente seleciona uma mensagem *m* $\in$ $\mathcal{M}$ arbitrária, tal que |*m*| = 2*n*. Seja *m<sub>1</sub>* os primeiros *n* bits de *m* e *m<sub>2</sub>* os últimos *n* bits. Primeiramente, *A* avalia Mac(*m<sub>2</sub>*||0<sup>n</sup>) = *F<sub>k</sub>*(*m<sub>2</sub>*)||*F<sub>k</sub>*(*F<sub>k</sub>*(0<sup>n</sup>)) e guarda os primeiros *n* bits da saída, ou seja, *x<sub>1</sub>* = *F<sub>k</sub>*(*m<sub>2</sub>*). Semelhantemente, avalia Mac(1<sup>n</sup>||*m<sub>2</sub>*) = *F<sub>k</sub>*(1<sup>n</sub>)||*F<sub>k</sub>*(*F<sub>k</sub>*(*m<sub>2</sub>*)) = *F<sub>k</sub>*(1<sup>n</sub>)||*F<sub>k</sub>*(*x<sub>1</sub>*), com *y<sub>1</sub>* = *F<sub>k</sub>*(*x<sub>1</sub>*); e Mac(0<sup>n</sup>||1<sup>n</sup>) = *F<sub>k</sub>*(0<sup>n</sub>)||*F<sub>k</sub>*(*F<sub>k</sub>*(1<sup>n</sup>)), com *y<sub>0</sub>* = *F<sub>k</sub>*(0<sup>n</sub>). Por fim, basta devolver o par (*m* = 0<sup>n</sup>||*m<sub>2</sub>*, *t* = *y<sub>0</sub>*||*y<sub>1</sub>*) que *A* foi bem sucedido no experimento.

## 4.8) Given any *deterministic* MAC (Mac, Vrfy), we may view Mac as a keyed function. In both Constructions 4.5 and 4.9, Mac is a pseudorandom function. Give a construction of a secure, deterministic MAC in which Mac is *not* a pseudorandom function.
Buscamos um MAC seguro, determinístico mas que não seja função pseudoaleatória. Seja $\Pi$ = (Gen, Mac, Vrfy) um MAC seguro conforme a Construção 4.5 e seja *F<sub>k</sub>* uma função pseudoaleatória. Podemos construir $\Pi$' = (Gen, Mac', Vrfy') a partir de $\Pi$, $\forall$ *m* $\in$ $\mathcal{M}$ tal que |*m*| = *n*, com Mac'(*m*) = Mac(*m*)||0 e Vrfy'(*t*) = Vrfy(*t*[1:*n*]), ou seja, Vrfy' ignora o 0 adicionado no fim. 
Para provarmos que $\Pi$' não é uma função pseudoaleatória, podemos supor um diferenciador *D* sujeito a um experimento de indistinguibilidade, em que *D* recebe acesso oráculo à uma função, e busca descobrir se trata-se de $\Pi$' ou de uma função aleatória de verdade. Basta *D* dar como entrada qualquer mensagem *m* arbitrária e devolver 1 (se trata de $\Pi$') caso o tamanho da saída seja *n*+1, e 0 caso contrário.
Para provarmos que $\Pi$' é seguro, vamos realizar uma redução baseada na sua construção a partir da contrapositiva de sua segurança, ou seja, $\Pi$' não é seguro $\implies$ $\Pi$ não é seguro. Suponhamos *A*' um adversário PPT sujeito ao experimento de segurança Mac-forge<sub>A', Π'</sub>() para $\Pi$'. Suponhamos que $\Pi$' não é seguro, isto é, P[Mac-forge<sub>A', Π'</sub>(*m*) = 1] > *negl*. Podemos construir adversário *A* capaz de atacar $\Pi$ com sucesso a partir de *A*'. Funciona da seguinte forma: *A* recebe acesso ao oráculo Mac(*m*) e busca gerar par (*m*, *t*) tal que *t* é tag válida para *m* e *m* $\notin$ *Q*. A única função realizada por *A* é chamar *A*' e devolver o mesmo par que receber como resposta, apenas removendo o último bit da tag, ou seja, (*m*', *t*') $\leftarrow$ *A*'() && *A* devolve (*m*', *t*'[1:*n*]). Assim *A* será bem sucedido $\iff$ *A*' for bem sucedido. Porém, como $\Pi$ é seguro por definição, *A* não pode existir, implicando que *A*' também não. Portanto, $\Pi$' é seguro e o enunciado segue.

## 4.9) Is Construction 4.5 necessarily secure when instantiated using a weak pseudorandom function (cf. Exercise 3.28)? Explain.
Uma função pseudoaleatória é dita fraca se é indistinguível de uma função aleatória quando qualquer adversário *D* PPT tem acesso apenas às saídas da função relativas à entradas amostradas uniformemente. Isso significa que se o adversário pode selecionar qualquer entrada arbitrária, não necessariamente a função se comporta de forma pseudoaleatória. Portanto, não é possível afirmar que um MAC baseado na Construção 4.5 com uma função pseudoaleatória é seguro. Como qualquer adversário *A*, quando sujeito a um experimento Mac-forge, pode realizar um número polinomial de consultas no oráculo Mac<sub>k</sub>(.) a partir de mensagens arbitrárias, não há garantia de que a função em questão se comportará uniformemente.
Suponhamos um MAC baseado na construção 4.5 que utiliza a função pseudoaleatória fraca do exercício 3.28.b) (*F<sub>k</sub>* $\stackrel{\text{def}}{=}$ *F'<sub>k</sub>*(*x*) se *x* é par e *F'<sub>k</sub>*(*x*+1) se *x* é impar; com *F'<sub>k</sub>* uma função pseudoaleatória). Trivialmente, metade dos elementos da Imagem da função tem probabilidade = 0 de pertencerem ao Contradomínio, e, juntamente, metade das saídas tem o mesmo valor. Assim, dada uma mensagem *m* $\in$ $\mathcal{M}$ arbitrária tal que *m* "é par", um adversário pode devolver o par (*m'* = *m*+1, *t'* = Mac<sub>k</sub>(*m*)).

## 4.10) Prove that Construction 4.7 is a secure MAC even when the adversary is additionally given access to a Vrfy oracle (cf. Exercise 4.1), assuming $\Pi$' is a secure MAC that uses canonical verification.
Buscamos provar que $\Pi$ é seguro mesmo quando sujeito à um experimento Mac-forge em que o adversário tem acesso à um oráculo Vrfy. Por definição e pelo exercício 4.1, sabemos que $\Pi$' é seguro nessas condições, já que usa verificação canônica. O buscado é provar que $\Pi$' é seguro $\implies$$\Pi$ é seguro, e como sempre, vamos adotar a estratégia de provar a contrapositiva por redução, ou seja, que $\Pi$ não é seguro $\implies$ $\Pi$' não é seguro. Suponhamos que $\Pi$ seja um MAC não seguro para as condições do enunciado. Isso significa que para qualquer adversário *A* PPT, P[Mac-forge'<sub>A, Π</sub>(1<sup>n</sup>) = 1] > *negl*, ou seja, *A* consegue gerar uma tag *t* válida para uma mensagem *m* $\notin$ *Q* arbitrária com probabilidade maior do que insignificante. Como $\Pi$ é construído com base em $\Pi$', podemos construir um adversário *A*' PPT baseado em *A* capaz de atacar $\Pi$'. O adversário *A*' seleciona uma mensagem *m* $\in$ $\mathcal{M}$ arbitrária, com |*m*| = *n* e passa como mensagem para *A* gerar uma tag válida. *A*' recebe como saída de *A* o conjunto (*r*, *t<sub>1</sub>*, *t<sub>2</sub>*, *t<sub>3</sub>*, *t<sub>4</sub>*), em que cada *t<sub>i</sub>* = Mac'<sub>k</sub>(*r*||*l*||*i*||*m<sub>i</sub>*) por definição. Basta então *A*' devolver o par [*m* = (*r*||[*n*/4]||0||*m<sub>0</sub>*), *t* = *t<sub>1</sub>*], que será bem sucedido no experimento Mac-forge' com probabilidade maior que insignificante e em tempo polinomial. Como $\Pi$ é seguro por definição, *A* é impossível de existir, e consequentemente, *A*' também, provando que $\Pi$ é seguro. É possível provar também que o oráculo de verificação Vrfy' pode ser simulado a partir do oráculo Vrfy.
